#include "GL/glew.h"
#include <SFML/Graphics.hpp>
#include <SFML/Window.hpp>
#include <SFML/OpenGL.hpp>
#include <cmath>
#include <iostream>
#include "../../shaders/Shader.h"




int main()
{


    // crée la fenêtre
    sf::Window window(sf::VideoMode(800, 600), "OpenGL", sf::Style::Default, sf::ContextSettings(32));
    window.setVerticalSyncEnabled(true);

       glewExperimental = GL_TRUE;
    GLenum glewCode = glewInit();
      if(GLEW_OK != glewCode) {
        std::cerr << "Unable to initialize GLEW : " << glewGetErrorString(glewCode) << std::endl;
        return false;
      }

    // Création du shader
    Shader shaderBasique("shaders_sources/color2d.vs.glsl", "shaders_sources/color2d.fs.glsl"); //constructeur
    if(shaderBasique.charger()==true){
        std::cout<< "yes we did it"<<std::endl;
    }
    else{
        std::cout<< "FAIL"<<std::endl;
    }
    // lecture et compilation des fichiers sources



    // la boucle principale

        // création du tableau de vertices
        //face du fond
            GLfloat vertices[] = {-1.0, -1.0, -1.0,   1.0, -1.0, -1.0,   1.0, 1.0, -1.0,     // Triangle 1
                                  -1.0, -1.0, -1.0,   -1.0, 1.0, -1.0,   1.0, 1.0, -1.0};    // Triangle 2
            // Couleurs
            float couleurs[] = {1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,           // Triangle 1
                                1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0};          // Triangle 2
            // Shader pour les couleurs

            Shader shaderCouleur("shaders_sources/color2d.vs.glsl", "shaders_sources/color2d.fs.glsl");
            shaderCouleur.charger();


        bool running = true;
        while (running)
        {
            // gestion des évènements
            sf::Event event;
            while (window.pollEvent(event))
            {
                if (event.type == sf::Event::Closed)
                {
                    // on stoppe le programme
                    running = false;
                }
                else if (event.type == sf::Event::Resized)
                {
                    // on ajuste le viewport lorsque la fenêtre est redimensionnée
                    glViewport(0, 0, event.size.width, event.size.height);
                }
            }

            // effacement les tampons de couleur/profondeur
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            //                                  DESSIN
            // Activation du shader
            glUseProgram(shaderBasique.getProgramID());


            // On remplie puis on active le tableau Vertex Attrib 0
            glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, vertices);
            glEnableVertexAttribArray(0);


            // Affichage du triangle
           glDrawArrays(GL_TRIANGLES, 0, 3);


            // On désactive le tableau Vertex Attrib puisque l'on n'en a plus besoin
            glDisableVertexAttribArray(0);


            // Désactivation du shader
            glUseProgram(0);

            // termine la trame courante (en interne, échange les deux tampons de rendu)
            window.display();
        }

    // libération des ressources...
    return 0;
}
